<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Themuiz AI Chat</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts: Inter -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <!-- ResponsiveVoice JS for text-to-speech -->
  <script src="https://code.responsivevoice.org/responsivevoice.js?key=Negu9VLC"></script>
  <style>
    /* Ensure html and body take full height and prevent main page scrolling */
    html, body {
      height: 100%; /* Make html and body take full viewport height */
      overflow: hidden; /* Prevent scrolling on the entire page */
    }

    /* Custom animation for bubbles */
    @keyframes pop {
      0% { transform: scale(0.9); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    .animate-pop {
      animation: pop 0.3s ease-out;
    }
    /* Hide scrollbar for a cleaner look */
    .hide-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .hide-scrollbar {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    /* Custom style for strong tags to make text slightly larger */
    .bubble strong {
      font-size: 1.1em; /* Makes the text 10% larger than its parent */
      font-weight: 600; /* Ensure it's bold as well */
    }
  </style>
</head>
<body class="font-inter bg-gray-950 text-gray-100 flex flex-col h-full antialiased">
  <!-- Changed min-h-screen to h-full and added overflow:hidden to body in style -->

  <!-- Header Section -->
  <header class="bg-gray-900 text-white p-4 text-2xl md:text-3xl font-extrabold text-center shadow-lg rounded-b-xl">
    <span class="text-blue-400">üí¨</span> Themuiz AI Chat
  </header>

  <!-- Chat Box Section -->
  <div id="chat-box" class="flex-1 p-4 overflow-y-auto flex flex-col gap-3 bg-gray-900 rounded-xl m-4 shadow-inner hide-scrollbar">
    <!-- Initial bot message - Removed as per request -->
  </div>

  <!-- Input Area Section -->
  <div id="input-area" class="flex p-4 bg-gray-900 border-t border-gray-800 items-center gap-2 shadow-lg">
    <input
      type="text"
      id="user-input"
      placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì..."
      class="flex-1 p-3 border border-gray-700 rounded-full text-base outline-none bg-gray-800 text-gray-100 placeholder-gray-400 focus:ring-2 focus:ring-blue-500 transition-all duration-200"
    >
    <button
      onclick="sendMessage()"
      class="bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white p-3 rounded-full cursor-pointer font-semibold transition-colors duration-200 shadow-lg transform active:scale-95"
    >
      ‡∏™‡πà‡∏á
    </button>
  </div>

  <script>
    const chatBox = document.getElementById('chat-box');
    const input = document.getElementById('user-input');
    // API Key will be automatically provided by the system
    const apiKey = ""; 

    // Function to parse Markdown bold syntax (**text** or *text*) to HTML <strong>
    function parseMarkdownBold(text) {
      // Regex to find **text** or *text* and replace with <strong>text</strong>
      // It handles cases where * or ** are escaped or used literally within words
      let parsedText = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // For **bold**
      parsedText = parsedText.replace(/\*(.*?)\*/g, '<strong>$1</strong>'); // For *bold*
      return parsedText;
    }

    // Function to clean text for speech (remove Markdown asterisks)
    function cleanTextForSpeech(text) {
      // Remove all asterisks used for Markdown bolding
      // This regex handles both ** and *
      return text.replace(/\*\*|\*/g, '');
    }

    // Function to append chat bubbles
    function appendBubble(text, type) {
      const div = document.createElement('div');
      div.className = `bubble ${type} p-3 rounded-xl max-w-[80%] break-words shadow-md animate-pop`;
      
      if (type === 'user') {
        div.classList.add('bg-blue-600', 'text-white', 'self-end', 'rounded-br-none');
        div.innerHTML = parseMarkdownBold(text); // User messages don't need a play button
      } else if (type === 'bot') {
        div.classList.add('bg-gray-800', 'text-gray-200', 'self-start', 'rounded-bl-none', 'flex', 'flex-col', 'items-start', 'gap-2'); // Added flex-col and items-start for stacked content
        
        const textSpan = document.createElement('span');
        textSpan.innerHTML = parseMarkdownBold(text);
        div.appendChild(textSpan);

        // Container for play and copy buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'flex gap-2 mt-2'; // Add margin top for spacing

        const playButton = document.createElement('button');
        playButton.className = 'flex-shrink-0 bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-white text-xs px-2 py-1 rounded-full cursor-pointer transition-colors duration-200 shadow-sm transform active:scale-95';
        playButton.innerHTML = '‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á'; // Play icon and text
        playButton.title = '‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á'; // Tooltip for accessibility

        // Attach click event to play the text
        playButton.onclick = function() {
          const originalButtonText = playButton.innerHTML;
          // Check if responsiveVoice is loaded and not currently speaking
          if (typeof responsiveVoice !== 'undefined' && !responsiveVoice.isPlaying()) {
            playButton.innerHTML = 'üîä ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô...'; // Show playing status
            responsiveVoice.speak(cleanTextForSpeech(text), 'Thai Female', {
                onend: function() {
                    playButton.innerHTML = originalButtonText; // Reset button text when speech ends
                },
                onerror: function(e) {
                    console.error("ResponsiveVoice error:", e);
                    playButton.innerHTML = '‚ùå ‡πÄ‡∏•‡πà‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ'; // Show error status
                    setTimeout(() => {
                        playButton.innerHTML = originalButtonText;
                    }, 2000); // Reset after 2 seconds
                }
            });
          } else if (typeof responsiveVoice !== 'undefined' && responsiveVoice.isPlaying()) {
            console.log("ResponsiveVoice is already speaking. Please wait.");
            // No change to button text, as it's already playing something.
          } else {
            console.warn("ResponsiveVoice library not loaded or not ready.");
            playButton.innerHTML = '‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°'; // Show not ready status
            setTimeout(() => {
                playButton.innerHTML = originalButtonText;
            }, 2000); // Reset after 2 seconds
          }
        };
        buttonContainer.appendChild(playButton);

        const copyButton = document.createElement('button');
        copyButton.className = 'flex-shrink-0 bg-green-500 hover:bg-green-600 active:bg-green-700 text-white text-xs px-2 py-1 rounded-full cursor-pointer transition-colors duration-200 shadow-sm transform active:scale-95';
        copyButton.innerHTML = 'üìã ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å'; // Copy icon and text
        copyButton.title = '‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°'; // Tooltip for accessibility

        // Attach click event to copy the text
        copyButton.onclick = function() {
          const textToCopy = cleanTextForSpeech(text); // Use cleaned text for copying
          const tempTextArea = document.createElement('textarea');
          tempTextArea.value = textToCopy;
          document.body.appendChild(tempTextArea);
          tempTextArea.select();
          try {
            document.execCommand('copy');
            const originalButtonText = copyButton.innerHTML;
            copyButton.innerHTML = '‚úÖ ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß!';
            setTimeout(() => {
              copyButton.innerHTML = originalButtonText;
            }, 2000); // Change back after 2 seconds
          } catch (err) {
            console.error('Failed to copy text: ', err);
            // Fallback for older browsers or restricted environments
            // You might want to show a message to the user that copying failed
          }
          document.body.removeChild(tempTextArea);
        };
        buttonContainer.appendChild(copyButton);

        div.appendChild(buttonContainer); // Append the button container to the bot bubble
      }
      
      chatBox.appendChild(div);
      // Scroll to the bottom to show the latest message
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // Function to show a typing indicator
    let loadingBubble = null;
    function showLoadingIndicator() {
      loadingBubble = document.createElement('div');
      loadingBubble.className = 'bubble bot bg-gray-800 text-gray-400 self-start rounded-bl-none animate-pulse p-3 shadow-md';
      loadingBubble.innerHTML = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏¥‡∏î...'; // Simple animation for typing
      chatBox.appendChild(loadingBubble);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // Function to hide the typing indicator
    function hideLoadingIndicator() {
      if (loadingBubble) {
        chatBox.removeChild(loadingBubble);
        loadingBubble = null;
      }
    }

    // Function to send message
    async function sendMessage() {
      const userText = input.value.trim();
      if (!userText) return; // Don't send empty messages

      appendBubble(userText, 'user'); // Add user's message to chat
      input.value = ''; // Clear input field
      
      showLoadingIndicator(); // Show loading indicator

      try {
        const chatHistory = []; 
        // Set a simple persona instruction: female AI named '‡∏°‡∏∏‡πà‡∏¢'
        const personaInstruction = `‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ AI ‡∏ú‡∏π‡πâ‡∏´‡∏ç‡∏¥‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡∏ß‡πà‡∏≤ '‡∏°‡∏∏‡πà‡∏¢'`;

        // Prepend persona instruction to the user's message
        const fullPrompt = `${personaInstruction}\n\n‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: ${userText}`;
        chatHistory.push({ role: "user", parts: [{ text: fullPrompt }] });

        const payload = { contents: chatHistory };
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const result = await response.json();
        
        hideLoadingIndicator(); // Hide loading indicator

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
          const botReply = result.candidates[0].content.parts[0].text;
          appendBubble(botReply, 'bot'); // Add bot's reply to chat
        } else {
          appendBubble("‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á", 'bot'); // Fallback message
          console.error("Unexpected API response structure:", result);
        }
      } catch (error) {
        hideLoadingIndicator(); // Ensure loading indicator is hidden on error
        appendBubble("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï‡πÅ‡∏•‡∏∞‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á", 'bot');
        console.error("Error fetching from API:", error);
      }
    }

    // Allow sending message with Enter key
    input.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        sendMessage();
      }
    });

    // Ensure ResponsiveVoice is fully loaded and ready before use
    window.onload = function() {
        if (typeof responsiveVoice !== 'undefined') {
            // Assign a function to responsiveVoice.OnLoad to be executed when the library is ready
            responsiveVoice.OnLoad = function() {
                console.log("ResponsiveVoice library is fully loaded and ready.");
                // Speak an empty string silently to pre-load the voice data for 'Thai Female' voice.
                // This often helps reduce the delay for the first actual speech.
                responsiveVoice.speak("", "Thai Female"); 
            };
        } else {
            console.error("ResponsiveVoice.js script not detected. Text-to-speech may not work.");
            // Optionally, inform the user directly in the chat or UI if the script fails to load
            // appendBubble("‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", 'bot');
        }
    };
  </script>
</body>
</html>

